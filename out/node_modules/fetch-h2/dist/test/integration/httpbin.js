"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const fs = require("fs");
const already_1 = require("already");
const through2 = require("through2");
const index_1 = require("../../index");
const ca = fs.readFileSync("/tmp/fetch-h2-certs/ca.pem");
const cert = fs.readFileSync("/tmp/fetch-h2-certs/cert.pem");
const http1bin = `localhost:${process.env.HTTP1BIN_PORT}`;
const http2bin = `localhost:${process.env.HTTP2BIN_PORT}`;
const https1bin = `localhost:${process.env.HTTPS1PROXY_PORT}`;
[
    { scheme: "http:", site: http2bin, protos: ["http2"] },
    { scheme: "http:", site: http1bin, protos: ["http1"] },
    { scheme: "https:", site: https1bin, protos: ["http1"], certs: false },
    { scheme: "https:", site: https1bin, protos: ["http1"], certs: true },
]
    .forEach(({ site, scheme, protos, certs }) => {
    const host = `${scheme}//${site}`;
    const baseHost = new url_1.URL(host).origin;
    const name = `${site} (${protos[0]} over ${scheme.replace(":", "")})` +
        (certs ? ' (using explicit certificates)' : '');
    describe(name, () => {
        function wrapContext(fn) {
            return async () => {
                const { fetch, disconnectAll } = index_1.context({
                    httpsProtocols: protos,
                    session: certs
                        ? { ca, cert, rejectUnauthorized: false }
                        : { rejectUnauthorized: false },
                });
                // Disconnection shouldn't be necessary, fetch-h2 should unref
                // the sockets correctly.
                await fn(fetch, disconnectAll);
            };
        }
        it("should be possible to GET", wrapContext(async (fetch) => {
            const response = await fetch(`${host}/user-agent`);
            const data = await response.json();
            expect(data["user-agent"]).toContain("fetch-h2/");
        }));
        it("should be possible to POST JSON", wrapContext(async (fetch) => {
            const testData = { foo: "bar" };
            const response = await fetch(`${host}/post`, {
                body: new index_1.JsonBody(testData),
                method: "POST",
            });
            const data = await response.json();
            expect(testData).toEqual(data.json);
            // fetch-h2 should set content type for JsonBody
            expect(data.headers["Content-Type"]).toBe("application/json");
        }));
        it("should be possible to POST buffer-data", wrapContext(async (fetch) => {
            const testData = '{"foo": "data"}';
            const response = await fetch(`${host}/post`, {
                body: new index_1.DataBody(testData),
                method: "POST",
            });
            const data = await response.json();
            expect(data.data).toBe(testData);
            expect(data.headers).not.toHaveProperty("Content-Type");
        }));
        it("should be possible to POST already ended stream-data", wrapContext(async (fetch) => {
            const stream = through2();
            stream.write("foo");
            stream.write("bar");
            stream.end();
            const response = await fetch(`${host}/post`, {
                allowForbiddenHeaders: true,
                body: new index_1.StreamBody(stream),
                headers: { "content-length": "6" },
                method: "POST",
            });
            const data = await response.json();
            expect(data.data).toBe("foobar");
        }));
        it("should be possible to POST not yet ended stream-data", wrapContext(async (fetch) => {
            const stream = through2();
            const eventualResponse = fetch(`${host}/post`, {
                allowForbiddenHeaders: true,
                body: new index_1.StreamBody(stream),
                headers: { "content-length": "6" },
                method: "POST",
            });
            await already_1.delay(1);
            stream.write("foo");
            stream.write("bar");
            stream.end();
            const response = await eventualResponse;
            const data = await response.json();
            expect(data.data).toBe("foobar");
        }));
        it("should save and forward cookies", wrapContext(async (fetch, disconnectAll) => {
            const responseSet = await fetch(`${host}/cookies/set?foo=bar`, { redirect: "manual" });
            expect(responseSet.headers.has("location")).toBe(true);
            const redirectedTo = responseSet.headers.get("location");
            if (scheme === "https:")
                // Over TLS, we need to read the payload, or the socket will not
                // deref.
                await responseSet.text();
            const response = await fetch(baseHost + redirectedTo);
            const data = await response.json();
            expect(data.cookies).toEqual({ foo: "bar" });
            await disconnectAll();
        }));
        it("should handle (and follow) relative paths", wrapContext(async (fetch) => {
            const response = await fetch(`${host}/relative-redirect/2`, { redirect: "follow" });
            expect(response.url).toBe(`${host}/get`);
            await response.text();
        }));
        it("should be possible to GET gzip data", wrapContext(async (fetch) => {
            const response = await fetch(`${host}/gzip`);
            const data = await response.json();
            expect(data).toMatchObject({ gzipped: true, method: "GET" });
        }));
    });
});
//# sourceMappingURL=httpbin.js.map