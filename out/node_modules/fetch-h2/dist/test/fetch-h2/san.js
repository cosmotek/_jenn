"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const san_1 = require("../../lib/san");
describe("SAN", () => {
    describe("makeRegex", () => {
        it("should handle non alpha-numeric characters right", async () => {
            const regex = san_1.makeRegex("*.example-domain.com");
            expect(regex).toBe("^[^.]+\\.example\\-domain\\.com$");
            const re = new RegExp(regex);
            const testOrigin = "foo.example-domain.com";
            const m = testOrigin.match(re);
            expect(m[0]).toBe(testOrigin);
        });
        it("should not allow sub-domains", async () => {
            const regex = san_1.makeRegex("*.example-domain.com");
            const re = new RegExp(regex);
            const testOrigin = "sub.foo.example-domain.com";
            expect(testOrigin.match(re)).toBeNull();
        });
    });
    it("Should match on CN when no SAN is provided (plain)", () => {
        const cert = { subject: { CN: "foo.com" } };
        const { names, dynamic } = san_1.parseOrigin(cert);
        expect(names).toStrictEqual(["foo.com"]);
        expect(dynamic).toBe(undefined);
    });
    it("Should match on CN when no SAN is provided (dynamic)", () => {
        const cert = { subject: { CN: "*.foo.com" } };
        const { names, dynamic } = san_1.parseOrigin(cert);
        expect(names.length).toBe(0);
        expect(dynamic === null || dynamic === void 0 ? void 0 : dynamic("test.foo.com")).toBe(true);
    });
    describe("Multi wildcard domains", () => {
        it("Should throw on double-wildcards", () => {
            const cert = { subject: { CN: "*.*.foo.com" } };
            const test = () => san_1.parseOrigin(cert);
            expect(test).toThrow(/invalid/i);
        });
        const subjectaltname = [
            "DNS:foo.com",
            "DNS:bar.com",
            "DNS:example1.com",
            "DNS:*.example1.com",
            "DNS:*.example2.com",
        ].join(", ");
        const certs = [
            {
                name: "CN is wildcard",
                cert: {
                    subject: { CN: "*.example1.com" },
                    subjectaltname,
                },
            },
            {
                name: "CN is plain",
                cert: {
                    subject: { CN: "example1.com" },
                    subjectaltname,
                },
            },
            {
                name: "CN is wildcard but not in SAN",
                cert: {
                    subject: { CN: "*.invalid.com" },
                    subjectaltname,
                },
            },
            {
                name: "CN is plain but not in SAN",
                cert: {
                    subject: { CN: "invalid.com" },
                    subjectaltname,
                },
            },
        ];
        certs.forEach(({ name, cert }) => describe(name, () => {
            it(`Should not match other domains`, () => {
                const { names, dynamic } = san_1.parseOrigin(cert);
                expect(names.includes("invalid.com")).toBe(false);
                expect(dynamic === null || dynamic === void 0 ? void 0 : dynamic("invalid.com")).toBe(false);
                expect(dynamic === null || dynamic === void 0 ? void 0 : dynamic("test.invalid.com")).toBe(false);
                expect(dynamic === null || dynamic === void 0 ? void 0 : dynamic("sub.foo.com")).toBe(false);
                expect(dynamic === null || dynamic === void 0 ? void 0 : dynamic("sub.bar.com")).toBe(false);
            });
            it(`Should handle plain names`, () => {
                var _a, _b;
                const match = san_1.parseOrigin(cert);
                expect((_a = match.dynamic) === null || _a === void 0 ? void 0 : _a.call(match, "foo.com")).toBe(false);
                expect((_b = match.dynamic) === null || _b === void 0 ? void 0 : _b.call(match, "bar.com")).toBe(false);
                expect(match.names.includes("foo.com")).toBe(true);
                expect(match.names.includes("bar.com")).toBe(true);
                expect(match.names.includes("example1.com")).toBe(true);
            });
            it(`Should not wildcard plain names`, () => {
                var _a, _b;
                const match = san_1.parseOrigin(cert);
                expect((_a = match.dynamic) === null || _a === void 0 ? void 0 : _a.call(match, "sub.example1.com")).toBe(true);
                expect((_b = match.dynamic) === null || _b === void 0 ? void 0 : _b.call(match, "sub.example2.com")).toBe(true);
            });
        }));
    });
});
//# sourceMappingURL=san.js.map