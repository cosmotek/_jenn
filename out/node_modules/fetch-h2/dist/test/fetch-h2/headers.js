"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const headers_1 = require("../../lib/headers");
const toObject = (keyvals) => [...keyvals].reduce((prev, cur) => Object.assign(prev, { [cur[0]]: cur[1] }), {});
describe("headers", () => {
    describe("regular", () => {
        it("empty", async () => {
            const headers = new index_1.Headers();
            expect(toObject(headers.entries())).toMatchObject({});
        });
        it("value", async () => {
            const headers = new index_1.Headers({ a: "b" });
            expect(toObject(headers.entries()))
                .toMatchObject({ a: "b" });
        });
    });
    describe("guarded", () => {
        it("empty", async () => {
            const headers = new headers_1.GuardedHeaders("response");
            expect(toObject(headers.entries())).toMatchObject({});
        });
        it("value", async () => {
            const headers = new headers_1.GuardedHeaders("response", { a: "b" });
            expect(toObject(headers.entries()))
                .toMatchObject({ a: "b" });
        });
    });
    describe("iterable", () => {
        it("for-of iterable", async () => {
            const headers = new headers_1.GuardedHeaders("response");
            headers.append("foo", "bar");
            headers.append("foo", "baz");
            headers.append("a", "b");
            const test = {};
            for (const [key, value] of headers) {
                test[key] = value;
            }
            expect(test).toMatchObject({
                a: "b",
                foo: "bar,baz",
            });
        });
    });
});
//# sourceMappingURL=headers.js.map